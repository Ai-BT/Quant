# AI/ML 통합 가이드

## 1. 개요

이 시스템은 전통적인 퀀트 전략과 AI/ML 기반 전략을 모두 지원하며, 두 가지를 조합하여 사용할 수 있습니다.

## 2. AI/ML 전략 타입

### 2.1 LSTM 기반 예측 전략
- **용도**: 시계열 데이터를 활용한 가격 방향 예측
- **모델**: LSTM (Long Short-Term Memory)
- **입력**: 과거 가격, 거래량, 기술적 지표
- **출력**: 매수/매도 확률 또는 가격 예측

### 2.2 Transformer 기반 전략
- **용도**: 시계열 데이터의 장기 의존성 학습
- **모델**: Transformer (Attention Mechanism)
- **입력**: 시계열 데이터 (가격, 거래량 등)
- **출력**: 매수/매도 신호

### 2.3 XGBoost 분류 전략
- **용도**: 다양한 특성을 조합한 분류 문제
- **모델**: XGBoost (Gradient Boosting)
- **입력**: 기술적 지표, 가격 특성, 거래량 특성
- **출력**: 매수/매도/보유 클래스

### 2.4 앙상블 전략
- **용도**: 여러 모델의 결과를 조합
- **방법**: Voting, Stacking, Blending
- **장점**: 단일 모델보다 안정적인 성능

## 3. 모델 학습 파이프라인

### 3.1 데이터 수집
```
1. 과거 시장 데이터 수집 (OHLCV)
2. 기술적 지표 계산
3. 특성 엔지니어링
4. 라벨링 (매수/매도/보유)
5. 데이터 검증 및 정제
```

### 3.2 특성 엔지니어링
- **가격 특성**: 종가, 시가, 고가, 저가, 변동률
- **거래량 특성**: 거래량, 거래량 평균, 거래량 비율
- **기술적 지표**: SMA, EMA, MACD, RSI, Bollinger Bands 등
- **시계열 특성**: 지연 특성, 이동 평균, 롤링 통계

### 3.3 모델 학습
```
1. 데이터 분할 (Train/Validation/Test)
2. 특성 정규화/표준화
3. 모델 초기화
4. 하이퍼파라미터 튜닝
5. 학습 실행
6. 검증 세트로 평가
7. 테스트 세트로 최종 평가
```

### 3.4 모델 평가
- **분류 문제**: Accuracy, Precision, Recall, F1-Score
- **회귀 문제**: MSE, MAE, RMSE, R²
- **트레이딩 관점**: 수익률, 샤프 비율, 최대 낙폭, 승률

### 3.5 모델 저장 및 버전 관리
- 모델 파일 저장 (파일 시스템 또는 S3)
- 모델 메타데이터 DB 저장
- 버전 관리 (MLflow 또는 자체 시스템)
- 성능 메트릭 기록

## 4. 모델 추론 파이프라인

### 4.1 실시간 추론
```
1. Strategy Engine이 시장 데이터 수집
2. 특성 추출 및 전처리
3. ML Model Service에 추론 요청
4. 모델 로드 및 추론 실행
5. 결과 반환 (매수/매도 확률 또는 신호)
6. Strategy Engine이 결과 기반으로 신호 생성
```

### 4.2 배치 추론
- 대량 데이터에 대한 일괄 추론
- 백테스트 시 사용
- 성능 평가용

## 5. 전통 전략과 AI 전략 통합

### 5.1 하이브리드 전략
- 전통 전략과 AI 전략의 신호를 조합
- 예: SMA 크로스오버 + LSTM 예측 조합
- Voting 또는 Weighted Voting 방식

### 5.2 전략 선택
- 조건에 따라 전통 전략 또는 AI 전략 선택
- 예: 변동성이 높을 때는 AI 전략, 낮을 때는 전통 전략

### 5.3 신호 필터링
- AI 모델의 확률이 높을 때만 신호 생성
- 전통 전략 신호를 AI 모델로 검증

## 6. 모델 관리

### 6.1 모델 버전 관리
- 여러 버전의 모델을 동시에 관리
- A/B 테스트를 통한 성능 비교
- 최고 성능 모델 자동 선택

### 6.2 모델 재학습
- 주기적 재학습 (일별, 주별, 월별)
- 성능 저하 시 자동 재학습 트리거
- 온라인 학습 (점진적 업데이트)

### 6.3 모델 모니터링
- 추론 성능 모니터링
- 예측 정확도 추적
- 모델 드리프트 감지

## 7. ML 모델 API

### 7.1 모델 관리 API
- `GET /api/v1/ml-models` - 모델 목록
- `GET /api/v1/ml-models/{id}` - 모델 상세
- `POST /api/v1/ml-models` - 모델 등록
- `PUT /api/v1/ml-models/{id}` - 모델 업데이트
- `DELETE /api/v1/ml-models/{id}` - 모델 삭제

### 7.2 학습 API
- `POST /api/v1/ml-models/{id}/train` - 모델 학습 요청
- `GET /api/v1/ml-models/{id}/training-status` - 학습 상태 조회
- `GET /api/v1/ml-models/{id}/training-history` - 학습 이력 조회

### 7.3 추론 API
- `POST /api/v1/ml-models/{id}/predict` - 추론 요청
- `POST /api/v1/ml-models/{id}/batch-predict` - 배치 추론

### 7.4 평가 API
- `GET /api/v1/ml-models/{id}/metrics` - 모델 성능 메트릭
- `POST /api/v1/ml-models/{id}/evaluate` - 모델 평가 실행
- `GET /api/v1/ml-models/{id}/backtest` - 백테스트 결과

## 8. 데이터 흐름

### 8.1 학습 데이터 흐름
```
1. 과거 시장 데이터 수집 (Upbit API)
2. 특성 엔지니어링 (Technical Indicators, Price Features)
3. 라벨링 (매수/매도/보유)
4. 데이터 전처리 및 정제
5. 학습 데이터셋 생성
6. 모델 학습
7. 모델 평가
8. 모델 저장 및 버전 관리
```

### 8.2 추론 데이터 흐름
```
1. Strategy Engine이 현재 시장 데이터 수집
2. 특성 추출 (동일한 전처리 파이프라인)
3. ML Model Service에 추론 요청
4. 모델 로드 (캐시된 모델 또는 디스크에서 로드)
5. 추론 실행
6. 결과 반환 (확률 또는 신호)
7. Strategy Engine이 결과 해석 및 신호 생성
```

## 9. 성능 최적화

### 9.1 모델 최적화
- 모델 양자화 (Quantization)
- 모델 압축 (Pruning)
- 배치 추론으로 처리량 향상

### 9.2 추론 최적화
- 모델 캐싱 (메모리)
- GPU 활용 (CUDA)
- 비동기 추론

### 9.3 데이터 최적화
- 데이터 전처리 캐싱
- 특성 계산 최적화
- 배치 처리

## 10. 보안 및 안정성

### 10.1 모델 검증
- 추론 결과 검증
- 이상치 감지
- 신뢰도 임계값 설정

### 10.2 폴백 메커니즘
- 모델 추론 실패 시 전통 전략으로 전환
- 모델 로드 실패 시 이전 버전 사용

### 10.3 모델 보안
- 모델 파일 무결성 검증
- 접근 권한 관리
- 모델 암호화 (선택사항)

